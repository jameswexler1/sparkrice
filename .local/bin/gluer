#!/bin/bash

# Ask which folder
folder_selection=$(printf "Home\nDownloads\nVideos" | dmenu -p "Choose target folder:")
[ -z "$folder_selection" ] && notify-send "No folder chosen. Exiting." && exit 1

case "$folder_selection" in
	Home) folder_path="$HOME" ;;
	Downloads) folder_path="$HOME/Downloads" ;;
	Videos) folder_path="$HOME/Videos" ;;
	*) notify-send "Invalid folder. Exiting." && exit 1 ;;
esac

# Build file list
file_list=()
while IFS= read -r file; do
    file_list+=("$(basename "$file")")
done < <(find "$folder_path" -maxdepth 1 -name "*.mp4")

# Ask which first file
file_selection1=$(printf "%s\n" "${file_list[@]}" | dmenu -p "Select first file:")
[ -z "$file_selection1" ] && notify-send "No first file selected. Exiting." && exit 1

# Ask which second file
file_selection2=$(printf "%s\n" "${file_list[@]}" | dmenu -p "Select second file:")
[ -z "$file_selection2" ] && notify-send "No second file selected. Exiting." && exit 1

if [ "$file_selection1" = "$file_selection2" ]; then
  notify-send "Cannot glue the same file to itself. Exiting."
  exit 1
fi

VIDEO1="$folder_path/$file_selection1"
VIDEO2="$folder_path/$file_selection2"

# Notify start
notify-send "Gluer" "Gluing started..."

# Generate output filename
BASE1="${VIDEO1%.*}"
BASE2="${VIDEO2%.*}"
EXT="${VIDEO1##*.}"
OUTPUT="${BASE1}_glued_with_${BASE2##*/}.$EXT"

# Get video properties using ffprobe
get_video_props() {
  ffprobe -v error -select_streams v:0 -show_entries stream=width,height,r_frame_rate,codec_name -of default=noprint_wrappers=1:nokey=1 "$1"
}

props1=$(get_video_props "$VIDEO1")
props2=$(get_video_props "$VIDEO2")

width1=$(echo "$props1" | sed -n 1p)
height1=$(echo "$props1" | sed -n 2p)
fps1=$(echo "$props1" | sed -n 3p)
codec1=$(echo "$props1" | sed -n 4p)

width2=$(echo "$props2" | sed -n 1p)
height2=$(echo "$props2" | sed -n 2p)
fps2=$(echo "$props2" | sed -n 3p)
codec2=$(echo "$props2" | sed -n 4p)

# Check if properties match
if [ "$width1" = "$width2" ] && [ "$height1" = "$height2" ] && [ "$fps1" = "$fps2" ] && [ "$codec1" = "$codec2" ]; then
  # Properties match, use fast TS method
  ts1=$(mktemp /tmp/video1.XXXXXX.ts)
  ts2=$(mktemp /tmp/video2.XXXXXX.ts)

  ffmpeg -i "$VIDEO1" -c copy -bsf:v h264_mp4toannexb -f mpegts "$ts1"
  if [ $? -ne 0 ]; then
    notify-send "Gluer" "Error converting first video."
    rm "$ts1" "$ts2"
    exit 1
  fi

  ffmpeg -i "$VIDEO2" -c copy -bsf:v h264_mp4toannexb -f mpegts "$ts2"
  if [ $? -ne 0 ]; then
    notify-send "Gluer" "Error converting second video."
    rm "$ts1" "$ts2"
    exit 1
  fi

  ffmpeg -i "concat:$ts1|$ts2" -c copy -bsf:a aac_adtstoasc "$OUTPUT"

  rm "$ts1" "$ts2"
else
  # Properties differ, use re-encoding with normalization
  filter=""
  v1="[1:v]"

  if [ "$fps1" != "$fps2" ]; then
    filter="${filter}${v1}fps=fps=${fps1}[v1f];"
    v1="[v1f]"
  fi

  if [ "$width1" != "$width2" ] || [ "$height1" != "$height2" ]; then
    filter="${filter}${v1}scale=${width1}:${height1}:force_original_aspect_ratio=decrease,pad=${width1}:${height1}:(ow-iw)/2:(oh-ih)/2[v1s];"
    v1="[v1s]"
  fi

  ffmpeg -i "$VIDEO1" -i "$VIDEO2" -filter_complex "[0:v][0:a]${v1}[1:a]concat=n=2:v=1:a=1[v][a]" -map "[v]" -map "[a]" "$OUTPUT"
fi

# Notify success or failure
if [ $? -eq 0 ]; then
	notify-send "Gluer" "Gluing finished"
else
	notify-send "Gluer" "Errors occurred"
fi
