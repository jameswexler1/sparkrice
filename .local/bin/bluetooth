#!/bin/bash

# Primary earbuds MAC (hardcoded for quick primary connect)
PRIMARY_MAC="F0:AE:66:D3:56:FF"
PRIMARY_NAME="Earbuds"  # For notifications; customize if needed

# Log file
LOG_FILE="/tmp/bluetooth_log.txt"

# Function to log messages
log() {
    echo "$(date) - $1" >> "$LOG_FILE"
}

# Function to turn off Bluetooth cleanly
turn_off_bluetooth() {
    log "Turning off Bluetooth."
    notify-send "Bluetooth" "Turning off..."
    bluetoothctl power off
    rfkill block bluetooth
}

# Optional MAC override from argument (for non-interactive use with other devices)
OVERRIDE_MAC="$1"

# Ensure Bluetooth service is running (adjust to user-level if needed)
if ! systemctl is-active --quiet bluetooth; then
    log "Starting Bluetooth service..."
    sudo systemctl start bluetooth  # Remove sudo if user-level
fi

# Check state using rfkill (as in original script for reliability)
if rfkill list bluetooth | grep -q "Soft blocked: no"; then
    # Bluetooth is not blocked (on); turn off
    turn_off_bluetooth
else
    # Bluetooth is blocked (off); turn on
    log "Unblocking and powering on Bluetooth..."
    rfkill unblock bluetooth
    bluetoothctl power on

    # Poll for power on
    for i in {1..10}; do
        if bluetoothctl show | grep -q "Powered: yes"; then
            break
        fi
        sleep 1
    done

    if ! bluetoothctl show | grep -q "Powered: yes"; then
        notify-send "Bluetooth" "Failed to power on."
        log "Failed to power on Bluetooth."
        exit 1
    fi

    notify-send "Bluetooth" "Bluetooth turned on."

    # Set agent
    bluetoothctl agent on
    bluetoothctl default-agent

    # Initialize flags
    MAC_ADDRESS=""
    CONNECTED=false

    # If override MAC provided, use it instead of primary logic
    if [ -n "$OVERRIDE_MAC" ]; then
        MAC_ADDRESS="$OVERRIDE_MAC"
        log "Using override MAC: $MAC_ADDRESS"
    else
        # Attempt primary (earbuds) connect
        notify-send "Bluetooth" "Attempting to connect to $PRIMARY_NAME..."
        log "Attempting primary connect to $PRIMARY_MAC"
        CONNECT_OUTPUT=$(bluetoothctl connect "$PRIMARY_MAC" 2>&1)
        if [ $? -eq 0 ]; then
            # Poll for connection
            for i in {1..10}; do
                if bluetoothctl info "$PRIMARY_MAC" | grep -q "Connected: yes"; then
                    notify-send "Bluetooth" "Successfully connected to $PRIMARY_NAME."
                    log "Successfully connected to $PRIMARY_MAC."
                    CONNECTED=true
                    MAC_ADDRESS="$PRIMARY_MAC"  # Set to skip selection and handle in final block
                    break
                fi
                sleep 1
            done
        fi

        if [ "$CONNECTED" = false ]; then
            notify-send "Bluetooth" "Failed to connect to $PRIMARY_NAME: ${CONNECT_OUTPUT:0:50}..."
            log "Primary connect failed: $CONNECT_OUTPUT"

            # Prompt if want to scan for other devices (via dmenu)
            PROMPT_RESPONSE=$(echo -e "Yes\nNo" | dmenu -p "Scan for other devices?")
            if [ "$PROMPT_RESPONSE" != "Yes" ]; then
                log "User declined other devices or canceled."
                turn_off_bluetooth
                exit 0
            fi

            # Scan for discovered devices (not just paired)
            notify-send "Bluetooth" "Scanning for devices..."
            log "Starting device scan..."
            bluetoothctl scan on
            sleep 10  # Give time to discover; adjust if needed
            DISCOVERED_DEVICES=$(bluetoothctl devices)
            bluetoothctl scan off
            log "Scan complete. Discovered: $DISCOVERED_DEVICES"

            if [ -z "$DISCOVERED_DEVICES" ]; then
                notify-send "Bluetooth" "No devices discovered."
                log "No devices discovered."
                turn_off_bluetooth
                exit 1
            fi

            # Prompt with dmenu: Show "Name (MAC)" or just MAC if no name
            SELECTED=$(echo "$DISCOVERED_DEVICES" | awk '{mac=$2; name=""; for(i=3;i<=NF;i++) name=name $i " "; if (name) printf "%s (%s)\n", name, mac; else printf "%s\n", mac}' | dmenu -p "Select Bluetooth device:")
            if [ -z "$SELECTED" ]; then
                notify-send "Bluetooth" "No device selected."
                log "Device selection canceled."
                turn_off_bluetooth
                exit 0
            fi

            # Extract MAC from selection (handles "Name (MAC)" or plain MAC)
            MAC_ADDRESS=$(echo "$SELECTED" | grep -oE '([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}' || echo "$SELECTED")
            log "Selected device: $SELECTED (MAC: $MAC_ADDRESS)"

            # Check if paired; pair/trust if not
            if ! bluetoothctl info "$MAC_ADDRESS" | grep -q "Paired: yes"; then
                notify-send "Bluetooth" "Pairing device..."
                log "Pairing $MAC_ADDRESS"
                bluetoothctl pair "$MAC_ADDRESS"
                sleep 2
                bluetoothctl trust "$MAC_ADDRESS"
                sleep 2
            fi
        fi
    fi

    # Attempt connection (for selected, override, or primary if set)
    if [ -n "$MAC_ADDRESS" ]; then
        # Pre-check if already connected
        if bluetoothctl info "$MAC_ADDRESS" | grep -q "Connected: yes"; then
            if [ "$CONNECTED" = false ]; then
                notify-send "Bluetooth" "Already connected to device."
                log "Already connected to $MAC_ADDRESS."
            fi
            CONNECTED=true
        else
            notify-send "Bluetooth" "Connecting to device..."
            CONNECT_OUTPUT=$(bluetoothctl connect "$MAC_ADDRESS" 2>&1)
            if [ $? -eq 0 ]; then
                # Poll for connection
                for i in {1..10}; do
                    if bluetoothctl info "$MAC_ADDRESS" | grep -q "Connected: yes"; then
                        notify-send "Bluetooth" "Successfully connected."
                        log "Successfully connected to $MAC_ADDRESS."
                        CONNECTED=true
                        break
                    fi
                    sleep 1
                done
                if [ "$CONNECTED" = false ]; then
                    notify-send "Bluetooth" "Connection timed out."
                    log "Connection timed out: $CONNECT_OUTPUT"
                    turn_off_bluetooth
                fi
            else
                notify-send "Bluetooth" "Failed to connect: ${CONNECT_OUTPUT:0:50}..."
                log "Failed to connect to $MAC_ADDRESS: $CONNECT_OUTPUT"
                turn_off_bluetooth
            fi
        fi
    fi
fi

# Update dwmblocks (after any state change)
kill -44 $(pidof dwmblocks)
