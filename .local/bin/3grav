#!/bin/bash

# Master Video Editor Script
# Dependencies: ffmpeg (including ffplay and ffprobe), dmenu, slop, xcolor, notify-send, xwininfo
# Usage: Run the script, select operation via dmenu, follow prompts.
# Note: For precise cropping, painting, watermarking, etc., ffplay is used to display the video for cursor selection.
# Requires the subtitle.lua script

HISTORY_FILE="$HOME/.video_edit_history"
mkdir -p "$(dirname "$HISTORY_FILE")"
touch "$HISTORY_FILE"

shopt -s nullglob

# Function to select folder
select_folder() {
    local folder_selection
    folder_selection=$(printf "Home\nDownloads\nCustom" | dmenu -p "Choose target folder:")
    [ -z "$folder_selection" ] && notify-send "No folder chosen. Exiting." && exit 1

    local folder_path
    case "$folder_selection" in
        Home) folder_path="$HOME" ;;
        Downloads) folder_path="$HOME/Downloads" ;;
        Custom) folder_path=$(dmenu -p "Enter custom path:") ;;
        *) notify-send "Invalid folder. Exiting." ; exit 1 ;;
    esac
    echo "$folder_path"
}

# Function to build file list (mp4, mkv, mov, webm, etc.)
build_file_list() {
    local folder="$1"
    local file_list=("All files")
    local file
    while IFS= read -r file; do
        file_list+=("$(basename "$file")")
    done < <(find "$folder" -maxdepth 1 \( -name "*.mp4" -o -name "*.mkv" -o -name "*.mov" -o -name "*.webm" -o -name "*.avi" \))
    printf "%s\n" "${file_list[@]}"
}

# Function to select file(s)
select_files() {
    local folder="$1"
    local batch_mode="$2"  # "single" or "batch"
    local file_list
    file_list=$(build_file_list "$folder")

    if [ "$batch_mode" = "single" ]; then
        local file_selection
        file_selection=$(printf "%s\n" "$file_list" | dmenu -p "Select file:")
        [ -z "$file_selection" ] && notify-send "No file selected. Exiting." && exit 1
        if [ "$file_selection" = "All files" ]; then
            printf "%s\n" "$folder"/*.{mp4,mkv,mov,webm,avi}
        else
            printf "%s\n" "$folder/$file_selection"
        fi
    else
        local selected_files=()
        while true; do
            local file_selection
            file_selection=$(printf "%s\n" "$file_list" | dmenu -p "Select file (empty to finish, All for all):")
            [ -z "$file_selection" ] && break
            if [ "$file_selection" = "All files" ]; then
                printf "%s\n" "$folder"/*.{mp4,mkv,mov,webm,avi}
                return
            fi
            selected_files+=("$folder/$file_selection")
        done
        printf "%s\n" "${selected_files[@]}"
    fi
}

# Function to build auxiliary file list (for logos, audio, srt, etc.)
build_aux_file_list() {
    local folder="$1"
    local extensions="$2"  # comma-separated, e.g., "png,jpg,jpeg"
    local ext_args=()
    IFS=',' read -r -a ext_array <<< "$extensions"
    for ext in "${ext_array[@]}"; do
        ext_args+=(-o -name "*.$ext")
    done
    unset 'ext_args[0]'  # Remove the first -o
    local file_list=()
    local file
    while IFS= read -r file; do
        file_list+=("$(basename "$file")")
    done < <(find "$folder" -maxdepth 1 "${ext_args[@]}")
    printf "%s\n" "${file_list[@]}"
}

# Function to select auxiliary file (single file from home, filtered by extensions)
select_aux_file() {
    local extensions="$1"
    local prompt="$2"
    local folder="$HOME"
    local file_list
    file_list=$(build_aux_file_list "$folder" "$extensions")
    local file_selection
    file_selection=$(printf "%s\n" "$file_list" | dmenu -p "$prompt")
    [ -z "$file_selection" ] && return
    echo "$folder/$file_selection"
}

# Function to get output file name
get_output_file() {
    local input_file="$1"
    local suffix="$2"
    local ext="${input_file##*.}"
    echo "${input_file%.*}${suffix}.${ext}"
}

# Function to get video resolution
get_resolution() {
    local input_file="$1"
    local width height
    width=$(ffprobe -v error -select_streams v:0 -show_entries stream=width -of csv=p=0 "$input_file")
    height=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$input_file")
    echo "$width $height"
}

# Function to get relative region using ffplay and slop, accounting for window scaling and letterboxing
get_relative_region() {
    local input_file="$1"
    local mode="${2:-region}"  # Default to region; alternative: position
    local res
    res=$(get_resolution "$input_file")
    read -r video_width video_height <<< "$res"
    local notify_msg="Opening video in ffplay for region selection. Pause with space if needed, then drag cursor to select region on the video window. Make sure to select within the video content area."
    if [ "$mode" = "position" ]; then
        notify_msg="Opening video in ffplay for position selection. Pause with space if needed, then select a small area around the desired placement point (center will be used)."
    fi
    notify-send "Video Editor" "$notify_msg"
    ffplay -noborder -x "$video_width" -y "$video_height" -i "$input_file" -loop 0 -window_title "Video Region Selection" &
    local pid=$!
    sleep 2  # Wait for window to open
    local window_info
    window_info=$(xwininfo -name "Video Region Selection" 2>/dev/null)
    if [ -z "$window_info" ]; then
        kill "$pid"
        notify-send "Error" "Could not find ffplay window. Ensure xwininfo is installed."
        exit 1
    fi
    local abs_x
    abs_x=$(echo "$window_info" | grep "Absolute upper-left X:" | awk '{print $4}')
    local abs_y
    abs_y=$(echo "$window_info" | grep "Absolute upper-left Y:" | awk '{print $4}')
    local win_width
    win_width=$(echo "$window_info" | grep "Width:" | awk '{print $2}')
    local win_height
    win_height=$(echo "$window_info" | grep "Height:" | awk '{print $2}')

    # Calculate scaling factor (preserving aspect ratio)
    local scale_w
    scale_w=$(awk "BEGIN {printf \"%.6f\", $win_width / $video_width}")
    local scale_h
    scale_h=$(awk "BEGIN {printf \"%.6f\", $win_height / $video_height}")
    local scale
    if (( $(awk "BEGIN {print ($scale_w < $scale_h)}") )); then
        scale=$scale_w
    else
        scale=$scale_h
    fi

    # Calculate displayed video dimensions
    local disp_w
    disp_w=$(awk "BEGIN {printf \"%.0f\", $video_width * $scale}")
    local disp_h
    disp_h=$(awk "BEGIN {printf \"%.0f\", $video_height * $scale}")

    # Calculate letterbox offsets (assuming centered)
    local offset_x
    offset_x=$(awk "BEGIN {printf \"%.0f\", ($win_width - $disp_w) / 2}")
    local offset_y
    offset_y=$(awk "BEGIN {printf \"%.0f\", ($win_height - $disp_h) / 2}")

    # Get selection
    local sel_x sel_y sel_w sel_h
    slop -f "%x %y %w %h" > /tmp/slop
    read -r sel_x sel_y sel_w sel_h < /tmp/slop
    rm /tmp/slop
    kill "$pid"
    wait "$pid" 2>/dev/null

    # Calculate relative coordinates, adjusted for scaling and offsets
    local rel_x
    rel_x=$(awk "BEGIN {printf \"%.0f\", ($sel_x - $abs_x - $offset_x) / $scale}")
    local rel_y
    rel_y=$(awk "BEGIN {printf \"%.0f\", ($sel_y - $abs_y - $offset_y) / $scale}")
    local rel_w
    rel_w=$(awk "BEGIN {printf \"%.0f\", $sel_w / $scale}")
    local rel_h
    rel_h=$(awk "BEGIN {printf \"%.0f\", $sel_h / $scale}")

    # Adjust for position mode (use center of selection)
    if [ "$mode" = "position" ]; then
        rel_x=$(awk "BEGIN {printf \"%.0f\", $rel_x + $rel_w / 2}")
        rel_y=$(awk "BEGIN {printf \"%.0f\", $rel_y + $rel_h / 2}")
    fi

    # Basic validation (ensure non-negative and within bounds, but allow user to proceed)
    if [ "$mode" = "region" ]; then
        if [ "$rel_x" -lt 0 ] || [ "$rel_y" -lt 0 ] || [ "$rel_w" -le 0 ] || [ "$rel_h" -le 0 ] || [ "$rel_x" -ge "$video_width" ] || [ "$rel_y" -ge "$video_height" ]; then
            notify-send "Warning" "Selected region may be out of bounds. Coordinates: $rel_x $rel_y $rel_w $rel_h"
        fi
    else  # position mode
        if [ "$rel_x" -lt 0 ] || [ "$rel_y" -lt 0 ] || [ "$rel_x" -ge "$video_width" ] || [ "$rel_y" -ge "$video_height" ]; then
            notify-send "Warning" "Selected position may be out of bounds. Coordinates: $rel_x $rel_y"
        fi
    fi

    echo "$rel_x $rel_y $rel_w $rel_h"
}

# Function to validate time format (seconds or HH:MM:SS)
validate_time() {
    local time="$1"
    if [[ "$time" =~ ^[0-9]+(\.[0-9]+)?$ ]] || [[ "$time" =~ ^([0-9]{1,2}:)?[0-9]{1,2}:[0-9]{1,2}(\.[0-9]+)?$ ]]; then
        return 0
    else
        return 1
    fi
}

# Function to validate numeric
validate_numeric() {
    local num="$1"
    if [[ "$num" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        return 0
    else
        return 1
    fi
}

# Function to validate volume db
validate_volume() {
    local db="$1"
    if [[ "$db" =~ ^[+-]?[0-9]+(\.[0-9]+)?$ ]]; then
        return 0
    else
        return 1
    fi
}

# Function to validate percentage change (e.g., +50, -20, +10.5)
validate_percentage() {
    local perc="$1"
    if [[ "$perc" =~ ^[+-]?[0-9]+(\.[0-9]+)?$ ]]; then
        return 0
    else
        return 1
    fi
}

# Function to preview and confirm command
preview_command() {
    local cmd="$1"
    notify-send "Preview Command" "$cmd"
    local response
    response=$(printf "No\nYes" | dmenu -i -p "Execute?")
    [ "$response" = "Yes" ]
}

# Function to log command to history
log_history() {
    local cmd="$1"
    echo "$cmd" >> "$HISTORY_FILE"
    # Keep last 20 unique commands
    tail -n 20 "$HISTORY_FILE" | awk '!seen[$0]++' > "$HISTORY_FILE.tmp"
    mv "$HISTORY_FILE.tmp" "$HISTORY_FILE"
}

# Function to select from history
select_history() {
    if [ ! -s "$HISTORY_FILE" ]; then
        notify-send "No history available."
        exit 1
    fi
    local selected_cmd
    selected_cmd=$(cat "$HISTORY_FILE" | dmenu -p "Select recent command:")
    [ -z "$selected_cmd" ] && exit 1
    echo "$selected_cmd"
}

# Main menu
main_menu() {
    local operation
    operation=$(printf "Crop\nCut/Trim\nResize/Scale\nSpeed Change\nRotate/Flip\nConcatenate\nSplit\nColor Paint\nOverlay Text\nWatermark\nPicture-in-Picture\nApply Filters\nStabilization\nExtract Audio\nReplace Audio\nAdjust Volume\nMute\nExtract Frame\nExtract Frames\nMake GIF\nConvert Format\nType Subtitles\nBurn Subtitles\nExtract Subtitles\nAdd Subtitles\nBatch Processing\nHistory Rerun" | dmenu -p "Select operation:")
    [ -z "$operation" ] && notify-send "No operation selected. Exiting." && exit 1
    echo "$operation"
}

# Feature functions
do_crop() {
    local input_file="$1"
    local X Y W H
    read -r X Y W H < <(get_relative_region "$input_file" "region")
    local output_file
    output_file=$(get_output_file "$input_file" "_cropped")
    local cmd="ffmpeg -y -i \"$input_file\" -vf crop=$W:$H:$X:$Y -c:v libx264 -crf 23 -preset fast -c:a copy \"$output_file\""
    echo "$cmd"
}

# Function to convert time to seconds
time_to_seconds() {
    local time="$1"
    if [[ "$time" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        echo "$time"
        return
    fi
    if [[ "$time" =~ ^([0-9]{1,2}:)?[0-9]{1,2}:[0-9]{1,2}(\.[0-9]+)?$ ]]; then
        IFS=':' read -r -a parts <<< "$time"
        local secs=0
        local len=${#parts[@]}
        if [ $len -eq 3 ]; then
            secs=$((parts[0]*3600 + parts[1]*60 + ${parts[2]%.*}))
            local frac="${parts[2]#*.}"
            [ -n "$frac" ] && secs="$secs.$frac"
        elif [ $len -eq 2 ]; then
            secs=$((parts[0]*60 + ${parts[1]%.*}))
            local frac="${parts[1]#*.}"
            [ -n "$frac" ] && secs="$secs.$frac"
        elif [ $len -eq 1 ]; then
            secs="${parts[0]}"
        fi
        echo "$secs"
    else
        echo ""
    fi
}

do_trim() {
    local input_file="$1"
    local lua_script="$HOME/.local/bin/trim.lua" # Adjust path if needed
    if [ ! -f "$lua_script" ]; then
        notify-send "Lua script not found at $lua_script."
        return
    fi
    local mode
    mode=$(printf "Keep segments\nRemove segments" | dmenu -p "Trim mode:")
    [ -z "$mode" ] && return
    if [ "$mode" = "Keep segments" ]; then
        mode="keep"
        seg_prompt="keep"
        notify_msg="Starting interactive trim with mpv (Keep mode). Play/pause with space, seek with arrows or mouse. Press 'a' to set start (A point), 'b' to set end (B point), 's' to add the current A-B segment to the keep list, CTRL+S to save and exit."
    else
        mode="remove"
        seg_prompt="remove"
        notify_msg="Starting interactive trim with mpv (Remove mode). Play/pause with space, seek with arrows or mouse. Press 'a' to set start (A point), 'b' to set end (B point), 's' to add the current A-B segment to the remove list, CTRL+S to save and exit."
    fi
    local input_method
    input_method=$(printf "Interactive (mpv)\nManual entry" | dmenu -p "Input method:")
    [ -z "$input_method" ] && return
    local segments=()
    if [ "$input_method" = "Manual entry" ]; then
        while true; do
            local entry
            entry=$(dmenu -p "Enter $seg_prompt segment (start:end, HH:MM:SS or secs; empty to finish):")
            [ -z "$entry" ] && break
            IFS=':' read -r start end <<< "$entry"
            if ! validate_time "$start" || ! validate_time "$end"; then
                notify-send "Invalid time format in '$entry'."
                continue
            fi
            local start_sec end_sec
            start_sec=$(time_to_seconds "$start")
            end_sec=$(time_to_seconds "$end")
            if [ -z "$start_sec" ] || [ -z "$end_sec" ]; then
                notify-send "Invalid time format in '$entry'."
                continue
            fi
            if awk "BEGIN {exit !($start_sec >= $end_sec)}"; then
                notify-send "Start must be before end in '$entry'."
                continue
            fi
            segments+=("$start_sec $end_sec")
        done
    else
        notify-send "$notify_msg"
        local segments_file="$HOME/.config/mpv/trim_segments.txt"
        rm -f "$segments_file" # Clean up any previous file
        mpv --msg-level=all=error --script="$lua_script" --script-opts=trim_mode="$mode" "$input_file" > /dev/null 2>&1
        if [ ! -f "$segments_file" ] || [ ! -s "$segments_file" ]; then
            notify-send "No segments saved or file empty."
            return
        fi
        mapfile -t segments < "$segments_file"
        rm "$segments_file"
    fi
    local num_seg=${#segments[@]}
    if [ $num_seg -eq 0 ]; then
        notify-send "No segments defined."
        return
    fi
    if [ "$mode" = "remove" ]; then
        local duration
        duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$input_file")
        # Sort segments by start
        mapfile -t sorted_segments < <(printf "%s\n" "${segments[@]}" | sort -n -k1)
        # Merge overlapping removes
        local merged=()
        if [ ${#sorted_segments[@]} -gt 0 ]; then
            local first
            first=(${sorted_segments[0]})
            local m_start="${first[0]}"
            local m_end="${first[1]}"
            for ((i=1; i<${#sorted_segments[@]}; i++)); do
                local curr
                curr=(${sorted_segments[$i]})
                if LC_NUMERIC=C awk "BEGIN {exit !($m_end >= ${curr[0]})}"; then
                    m_end=$(LC_NUMERIC=C awk "BEGIN {print ($m_end > ${curr[1]} ? $m_end : ${curr[1]})}")
                else
                    merged+=("$m_start $m_end")
                    m_start="${curr[0]}"
                    m_end="${curr[1]}"
                fi
            done
            merged+=("$m_start $m_end")
        fi
        # Compute keep segments
        local keeps=()
        local prev_end=0
        for remove in "${merged[@]}"; do
            local r_start r_end
            read -r r_start r_end <<< "$remove"
            if LC_NUMERIC=C awk "BEGIN {exit !($prev_end < $r_start)}"; then
                keeps+=("$prev_end $r_start")
            fi
            prev_end=$(LC_NUMERIC=C awk "BEGIN {print ($prev_end > $r_end ? $prev_end : $r_end)}")
        done
        if LC_NUMERIC=C awk "BEGIN {exit !($prev_end < $duration)}"; then
            keeps+=("$prev_end $duration")
        fi
        segments=("${keeps[@]}")
        num_seg=${#segments[@]}
        if [ $num_seg -eq 0 ]; then
            notify-send "Removals cover the entire video; nothing to keep."
            return
        fi
    fi
    local output_file
    output_file=$(get_output_file "$input_file" "_trimmed")
    local ext="${input_file##*.}"
    local cmd
    if [ $num_seg -eq 1 ]; then
        local start end
        read -r start end <<< "${segments[0]}"
        cmd="ffmpeg -y -i \"$input_file\" -ss $start -to $end -c copy \"$output_file\""
    else
        local temp_files=()
        local extract_cmds=()
        local concat_file="/tmp/trim_concat.txt"
        > "$concat_file"
        for i in "${!segments[@]}"; do
            local start end
            read -r start end <<< "${segments[$i]}"
            local temp="/tmp/trim_temp_${i}.${ext}"
            extract_cmds+=("ffmpeg -y -i \"$input_file\" -ss $start -to $end -c copy \"$temp\"")
            echo "file '$temp'" >> "$concat_file"
            temp_files+=("\"$temp\"")
        done
        # Fixed: Use printf loop to join extracts reliably with " && "
        local extracts
        if [ ${#extract_cmds[@]} -gt 0 ]; then
            extracts=$(printf "%s" "${extract_cmds[0]}")
            for ((i=1; i<${#extract_cmds[@]}; i++)); do
                extracts+=$(printf " && %s" "${extract_cmds[$i]}")
            done
        fi
        local cleanup="rm \"$concat_file\" ${temp_files[*]}"
        cmd="$extracts && ffmpeg -y -f concat -safe 0 -i \"$concat_file\" -c copy \"$output_file\" && $cleanup"
    fi
    echo "$cmd" > /tmp/trim_cmd.txt  # Debug: Save the exact cmd to file for inspection
    echo "$cmd"
}
do_speed() {
    local input_file="$1"
    local speed
    speed=$(dmenu -p "Speed factor (e.g., 0.5 for slow, 2 for fast):")
    [ -z "$speed" ] && return
    if ! validate_numeric "$speed"; then
        notify-send "Invalid speed factor (must be numeric)."
        return
    fi
    local output_file
    output_file=$(get_output_file "$input_file" "_speed${speed}")
    local cmd="ffmpeg -y -i \"$input_file\" -vf setpts=PTS/$speed -af atempo=$speed -c:v libx264 -crf 23 -preset fast -c:a aac \"$output_file\""
    echo "$cmd"
}

do_rotate() {
    local input_file="$1"
    local rotate
    rotate=$(printf "90° CW\n90° CCW\n180°\nFlip H\nFlip V" | dmenu -p "Select rotation/flip:")
    [ -z "$rotate" ] && return
    local filter
    case "$rotate" in
        "90° CW") filter="transpose=1" ;;
        "90° CCW") filter="transpose=2" ;;
        "180°") filter="transpose=1,transpose=1" ;;
        "Flip H") filter="hflip" ;;
        "Flip V") filter="vflip" ;;
    esac
    local output_file
    output_file=$(get_output_file "$input_file" "_rotated")
    local cmd="ffmpeg -y -i \"$input_file\" -vf $filter -c:v libx264 -crf 23 -preset fast -c:a copy \"$output_file\""
    echo "$cmd"
}

do_concat() {
    local folder="$1"
    local files_to_process
    mapfile -t files_to_process < <(select_files "$folder" "batch")
    if [ ${#files_to_process[@]} -lt 2 ]; then
        notify-send "Need at least two files for concatenation."
        return
    fi
    local output_file="$folder/concatenated.mp4"
    local concat_file="/tmp/concat.txt"
    > "$concat_file"
    local f
    for f in "${files_to_process[@]}"; do
        echo "file '$f'" >> "$concat_file"
    done
    local cmd="ffmpeg -y -f concat -safe 0 -i \"$concat_file\" -c copy \"$output_file\""
    echo "$cmd"
}

do_split() {
    local input_file="$1"
    local duration
    duration=$(dmenu -p "Segment duration (seconds):")
    [ -z "$duration" ] && return
    if ! validate_numeric "$duration"; then
        notify-send "Invalid duration (must be numeric)."
        return
    fi
    local output_prefix="${input_file%.*}_segment_%03d.${input_file##*.}"
    local cmd="ffmpeg -y -i \"$input_file\" -f segment -segment_time $duration -c copy \"$output_prefix\""
    echo "$cmd"
}

do_color_paint() {
    local input_file="$1"
    local X Y W H
    read -r X Y W H < <(get_relative_region "$input_file" "region")
    local color
    color=$(xcolor -S 4)  # Assuming xcolor picks hex
    [ -z "$color" ] && return
    local output_file
    output_file=$(get_output_file "$input_file" "_painted")
    local cmd="ffmpeg -y -i \"$input_file\" -vf drawbox=x=$X:y=$Y:w=$W:h=$H:color=$color@1.0:t=fill -c:v libx264 -crf 23 -preset fast -c:a copy \"$output_file\""
    echo "$cmd"
}

do_overlay_text() {
    local input_file="$1"
    local text
    text=$(dmenu -p "Enter text:")
    [ -z "$text" ] && return
    local font
    font=$(dmenu -p "Font file/path (or default):" <<< "/usr/share/fonts/TTF/dejavu/DejaVuSans.ttf")
    [ -z "$font" ] && return
    if [ ! -f "$font" ]; then
        notify-send "Font file not found."
        return
    fi
    local X Y _ _
    read -r X Y _ _ < <(get_relative_region "$input_file" "position")
    local size
    size=$(dmenu -p "Font size:" <<< "24")
    [ -z "$size" ] && return
    if ! validate_numeric "$size"; then
        notify-send "Invalid font size."
        return
    fi
    local color
    color=$(dmenu -p "Text color (hex):" <<< "white")
    [ -z "$color" ] && return
    local position="x=$X:y=$Y"
    local output_file
    output_file=$(get_output_file "$input_file" "_text")
    local cmd="ffmpeg -y -i \"$input_file\" -vf drawtext=fontfile='$font':text='$text':$position:fontsize=$size:fontcolor=$color -c:v libx264 -crf 23 -preset fast -c:a copy \"$output_file\""
    echo "$cmd"
}

do_watermark() {
    local input_file="$1"
    local logo_file
    logo_file=$(select_aux_file "png,jpg,jpeg,gif" "Select logo file:")
    [ -z "$logo_file" ] && return
    if [ ! -f "$logo_file" ]; then
        notify-send "Logo file not found."
        return
    fi
    local X Y _ _
    read -r X Y _ _ < <(get_relative_region "$input_file" "position")
    local output_file
    output_file=$(get_output_file "$input_file" "_watermarked")
    local cmd="ffmpeg -y -i \"$input_file\" -i \"$logo_file\" -filter_complex overlay=$X:$Y -c:v libx264 -crf 23 -preset fast -c:a copy \"$output_file\""
    echo "$cmd"
}

do_pip() {
    local input_file="$1"
    local overlay_video
    overlay_video=$(select_aux_file "mp4,mkv,mov,webm,avi" "Select overlay video file:")
    [ -z "$overlay_video" ] && return
    if [ ! -f "$overlay_video" ]; then
        notify-send "Overlay video not found."
        return
    fi
    local X Y _ _
    read -r X Y _ _ < <(get_relative_region "$input_file" "position")
    local position="$X:$Y"
    local output_file
    output_file=$(get_output_file "$input_file" "_pip")
    local cmd="ffmpeg -y -i \"$input_file\" -i \"$overlay_video\" -filter_complex [1:v]scale=320:240[ovrl],[0:v][ovrl]overlay=$position -c:v libx264 -crf 23 -preset fast -c:a copy \"$output_file\""
    echo "$cmd"
}

do_filters() {
    local input_file="$1"
    local filter
    filter=$(printf "grayscale\nsepia\nblur\ninvert" | dmenu -p "Select filter:")
    [ -z "$filter" ] && return
    local vf
    case "$filter" in
        grayscale) vf="colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3" ;;
        sepia) vf="colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131" ;;
        blur) vf="boxblur=2:1" ;;
        invert) vf="negate" ;;
    esac
    local output_file
    output_file=$(get_output_file "$input_file" "_filtered")
    local cmd="ffmpeg -y -i \"$input_file\" -vf $vf -c:v libx264 -crf 23 -preset fast -c:a copy \"$output_file\""
    echo "$cmd"
}

do_stabilization() {
    local input_file="$1"
    local output_file
    output_file=$(get_output_file "$input_file" "_stabilized")
    local cmd1="ffmpeg -y -i \"$input_file\" -vf vidstabdetect -f null -"
    local cmd2="ffmpeg -y -i \"$input_file\" -vf vidstabtransform -c:v libx264 -crf 23 -preset fast -c:a copy \"$output_file\""
    local cmd="$cmd1 && $cmd2"
    echo "$cmd"
}

do_extract_audio() {
    local input_file="$1"
    local format
    format=$(printf "mp3\nwav\nflac" | dmenu -p "Audio format:")
    [ -z "$format" ] && return
    local output_file="${input_file%.*}.$format"
    local cmd="ffmpeg -y -i \"$input_file\" \"$output_file\""
    echo "$cmd"
}

do_replace_audio() {
    local input_file="$1"
    local new_audio
    new_audio=$(select_aux_file "mp3,wav,flac,aac" "Select new audio file:")
    [ -z "$new_audio" ] && return
    if [ ! -f "$new_audio" ]; then
        notify-send "New audio file not found."
        return
    fi
    local output_file
    output_file=$(get_output_file "$input_file" "_newaudio")
    local cmd="ffmpeg -y -i \"$input_file\" -i \"$new_audio\" -c:v copy -map 0:v:0 -map 1:a:0 \"$output_file\""
    echo "$cmd"
}

do_adjust_volume() {
    local input_file="$1"
    local perc
    perc=$(dmenu -p "Volume change in % (e.g., +50 or -20):")
    [ -z "$perc" ] && return
    if ! validate_percentage "$perc"; then
        notify-send "Invalid percentage change (e.g., +50 or -20)."
        return
    fi
    # Compute gain using awk for floating-point
    local gain
    gain=$(awk "BEGIN {printf \"%.2f\", 1 + $perc / 100}")
    # Check if gain is positive
    if awk "BEGIN {exit !($gain > 0)}"; then
        :  # Gain is positive, proceed
    else
        notify-send "Invalid: Percentage would make volume zero or negative (e.g., -100 or lower)."
        return
    fi
    # Compute dB from gain (20 * log10(gain))
    local db
    db=$(awk "BEGIN {printf \"%.2f\", 20 * log($gain)/log(10)}")
    local output_file
    output_file=$(get_output_file "$input_file" "_volume")
    local cmd="ffmpeg -y -i \"$input_file\" -af volume=${db}dB -c:v copy -c:a aac \"$output_file\""
    echo "$cmd"
}

do_mute() {
    local input_file="$1"
    local output_file
    output_file=$(get_output_file "$input_file" "_muted")
    local cmd="ffmpeg -y -i \"$input_file\" -c copy -an \"$output_file\""
    echo "$cmd"
}

do_extract_frame() {
    local input_file="$1"
    local time
    time=$(dmenu -p "Timestamp (HH:MM:SS):")
    [ -z "$time" ] && return
    if ! validate_time "$time"; then
        notify-send "Invalid timestamp format."
        return
    fi
    local format
    format=$(printf "png\njpg" | dmenu -p "Format:")
    [ -z "$format" ] && return
    local output_file="${input_file%.*}_frame.$format"
    local cmd="ffmpeg -y -i \"$input_file\" -ss $time -vframes 1 \"$output_file\""
    echo "$cmd"
}

do_extract_frames() {
    local input_file="$1"
    local interval
    interval=$(dmenu -p "Interval (seconds):")
    [ -z "$interval" ] && return
    if ! validate_numeric "$interval"; then
        notify-send "Invalid interval."
        return
    fi
    local output_prefix="${input_file%.*}_frame_%04d.png"
    local cmd="ffmpeg -y -i \"$input_file\" -vf fps=1/$interval \"$output_prefix\""
    echo "$cmd"
}

do_make_gif() {
    local input_file="$1"
    local start
    start=$(dmenu -p "Start time:")
    [ -z "$start" ] && return
    if ! validate_time "$start"; then
        notify-send "Invalid start time."
        return
    fi
    local duration
    duration=$(dmenu -p "Duration (seconds):")
    [ -z "$duration" ] && return
    if ! validate_numeric "$duration"; then
        notify-send "Invalid duration."
        return
    fi
    local output_file="${input_file%.*}.gif"
    local cmd="ffmpeg -y -ss $start -t $duration -i \"$input_file\" -vf fps=10,scale=320:-1:flags=lanczos \"$output_file\""
    echo "$cmd"
}

do_convert_format() {
    local input_file="$1"
    local new_ext
    new_ext=$(dmenu -p "New format (e.g., mkv, webm):")
    [ -z "$new_ext" ] && return
    local output_file="${input_file%.*}.$new_ext"
    local cmd="ffmpeg -y -i \"$input_file\" -c copy \"$output_file\""
    echo "$cmd"
}

do_create_subtitles() {
    local input_file="$1"
    local lua_script="$HOME/.local/bin/subtitle.lua"  # Adjust path if needed
    if [ ! -f "$lua_script" ]; then
        notify-send "Lua script not found at $lua_script."
        return
    fi
    local output_srt="${input_file%.*}.srt"
    notify-send "Starting interactive subtitling with mpv. Press 'ctrl+a' to add subs, CTRL+S to save."
    mpv --msg-level=all=error --script="$lua_script" "$input_file" > /dev/null 2>&1
    # Move/rename the saved .srt
    if [ -f "$HOME/.config/mpv/output.srt" ]; then
        mv "$HOME/.config/mpv/output.srt" "$output_srt"
        notify-send "SRT created: $output_srt"
    else
        notify-send "Error: SRT file not created. Check if you added subs and saved."
        return
    fi
    # Now call existing burn function with the SRT
    do_burn_subtitles "$input_file" "$output_srt"
}

do_burn_subtitles() {
    local input_file="$1"
    local srt_file
    srt_file=$(select_aux_file "srt" "Select SRT file:")
    [ -z "$srt_file" ] && return
    if [ ! -f "$srt_file" ]; then
        notify-send "SRT file not found."
        return
    fi
    local output_file
    output_file=$(get_output_file "$input_file" "_subbed")
    local cmd="ffmpeg -y -i \"$input_file\" -vf subtitles=\"$srt_file\" -c:v libx264 -crf 23 -preset fast -c:a copy \"$output_file\""
    echo "$cmd"
}

do_extract_subtitles() {
    local input_file="$1"
    local output_file="${input_file%.*}.srt"
    local cmd="ffmpeg -y -i \"$input_file\" \"$output_file\""
    echo "$cmd"
}

do_add_subtitles() {
    local input_file="$1"
    local srt_file
    srt_file=$(select_aux_file "srt" "Select SRT file:")
    [ -z "$srt_file" ] && return
    if [ ! -f "$srt_file" ]; then
        notify-send "SRT file not found."
        return
    fi
    local output_file
    output_file=$(get_output_file "$input_file" "_withsubs")
    local cmd="ffmpeg -y -i \"$input_file\" -i \"$srt_file\" -c copy -c:s mov_text \"$output_file\""
    echo "$cmd"
}

# Main logic
folder=$(select_folder)
operation=$(main_menu)

batch_mode="single"
if [ "$operation" = "Batch Processing" ]; then
    batch_mode="batch"
    operation=$(main_menu)  # Select sub-operation for batch
fi

notify-send "Video Editor" "Processing started..."

any_failed=0
processed=0
cmd=""
if [ "$operation" = "History Rerun" ]; then
    cmd=$(select_history)
    if [ -n "$cmd" ] && preview_command "$cmd"; then
        eval "$cmd" || any_failed=1
        log_history "$cmd"
        processed=1
    fi
elif [ "$operation" = "Concatenate" ]; then
    cmd=$(do_concat "$folder")
    if [ -n "$cmd" ] && preview_command "$cmd"; then
        eval "$cmd" || any_failed=1
        log_history "$cmd"
        processed=1
    fi
else
    mapfile -t files < <(select_files "$folder" "$batch_mode")
    for file in "${files[@]}"; do
        case "$operation" in
            Crop) cmd=$(do_crop "$file") ;;
            "Cut/Trim") cmd=$(do_trim "$file") ;;
            "Resize/Scale") cmd=$(do_resize "$file") ;;
            "Speed Change") cmd=$(do_speed "$file") ;;
            "Rotate/Flip") cmd=$(do_rotate "$file") ;;
            Split) cmd=$(do_split "$file") ;;
            "Color Paint") cmd=$(do_color_paint "$file") ;;
            "Overlay Text") cmd=$(do_overlay_text "$file") ;;
            Watermark) cmd=$(do_watermark "$file") ;;
            "Picture-in-Picture") cmd=$(do_pip "$file") ;;
            "Apply Filters") cmd=$(do_filters "$file") ;;
            Stabilization) cmd=$(do_stabilization "$file") ;;
            "Extract Audio") cmd=$(do_extract_audio "$file") ;;
            "Replace Audio") cmd=$(do_replace_audio "$file") ;;
            "Adjust Volume") cmd=$(do_adjust_volume "$file") ;;
            Mute) cmd=$(do_mute "$file") ;;
            "Extract Frame") cmd=$(do_extract_frame "$file") ;;
            "Extract Frames") cmd=$(do_extract_frames "$file") ;;
            "Make GIF") cmd=$(do_make_gif "$file") ;;
            "Convert Format") cmd=$(do_convert_format "$file") ;;
	    "Type Subtitles") cmd=$(do_create_subtitles "$file") ;;
            "Burn Subtitles") cmd=$(do_burn_subtitles "$file") ;;
            "Extract Subtitles") cmd=$(do_extract_subtitles "$file") ;;
            "Add Subtitles") cmd=$(do_add_subtitles "$file") ;;
            *) notify-send "Unknown operation: $operation" ; continue ;;
        esac

        if [ -n "$cmd" ] && preview_command "$cmd"; then
            eval "$cmd" || any_failed=1
            log_history "$cmd"
            processed=$((processed + 1))
        fi
    done
fi

if [ "$processed" -eq 0 ]; then
    notify-send "Video Editor" "No processing performed (canceled or no commands executed)."
elif [ "$any_failed" -eq 0 ]; then
    notify-send "Video Editor" "Processing finished successfully."
else
    notify-send "Video Editor" "Processing finished with errors."
fi
